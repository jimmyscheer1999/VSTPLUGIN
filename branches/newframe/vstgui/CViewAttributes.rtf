{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fmodern\fcharset77 Courier;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww13740\viewh15700\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural

\f0\fs24 \cf0 \ul \ulc0 Attributes for CView:\ulnone \
\
The new attributes interface in CView is a new generic interface to set attributes for views without knowing its exactly class. \
A little scenario where it is usefull: Say you have an interface which is controlable via CC Midi Messages and you want to represent the CC Value to the user. Your interface consists of knobs, sliders, buttons etc. At the moment you subclass CKnob, CSlider etc and provide a method to set the CC Value and a method to hide and show it. Now if you want to set this value you have to cast every object to it's real class and then call the methods. With the new attribute interface you just can use the CControl class  to change these values. \
Here is a code where a button hides/shows the cc value :\
\

\f1\fs20 //-----------------------------------------------------------------------------\
void MyEditor::valueChanged (CDrawContext* c, CControl* control)\
\{\
	long tag = control->getTag ();\
	float value = control->getValue ();\
	if (tag == kHideShowCCValueTag)\
	\{\
		bool ccVisible = (value > 0.5f ? true : false);\
		for (long i = 0; i < myNumControls; i++)\
		\{\
			if (myControls[i]->setAttribute (kAttributeCCValueVisible, sizeof (bool), &ccVisible))\
			\{\
				myControls[i]->setDirty (true);\
			\}\
		\}\
	\}\
\}\

\f0\fs24 \
and here is the code for the attribute handling of a knob subclassed from CKnob :\
\

\f1\fs20 //-----------------------------------------------------------------------------\
bool MyKnob::getAttributeSize (const CViewAttributeID id, long& outSize) const\
\{\
	if (id == kAttributeCCValueVisible)\
	\{\
		outSize = sizeof (bool);\
		return true;\
	\}\
	return CKnob::getAttributeSize (id, outSize);\
\}\
\
//-----------------------------------------------------------------------------\
bool MyKnob::getAttribute (const CViewAttributeID id, const long inSize, void* outData, long& outSize) const\
\{\
	if (id == kAttributeCCValueVisible)\
	\{\
		if (inSize >= sizeof (bool))\
		\{\
			outSize = sizeof (bool);\
			*(bool*)outData = bCCValueVisible;\
			return true;\
		\}\
	\}\
	return CKnob::getAttribute (id, inSize, outData, outSize);\
\}\
\
//-----------------------------------------------------------------------------\
bool MyKnob::setAttribute (const CViewAttributeID id, const long inSize, void* inData)\
\{\
	if (id == kAttributeCCValueVisible)\
	\{\
		if (inSize == sizeof (bool))\
		\{\
			bCCValueVisible = *(bool*)inData;\
			return true;\
		\}\
	\}\
	return CKnob::setAttribute (id, inSize,inData);\
\}
\f0\fs24 \
\pard\tx565\tx1133\tx1700\tx2266\tx2833\tx3401\tx3967\tx4535\tx5102\tx5669\tx6235\tx6802\ql\qnatural
\cf0 \
The same you do for your CSlider subclass and all other classes where you need it.\
This makes your Editor class much easier as you don't have to remember all kinds of different views and controls. You just have an array of CViews or maybe CControls and that's it.\
As an example you can look at the CControl class where the tag and the value are accessable via this interface.\
\
}